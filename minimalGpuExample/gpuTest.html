<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GPGPU</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="gpu.js"></script>
		<script src="GetGridSys.js"></script>

    <script>
		var GPUcomputeAcceleration;
		function initGPUArrayMega(){
		   var gpu = new GPU()
		        GPUcomputeAcceleration =  gpu.createKernelMap(
		        [
		         function AccelerateSingle( pos,mass, acc,rad,CurrentDimension){
		          var G = 2.93558 * Math.pow(10, -4);
		          var accx = 0;
		          var accy = 0;
		          var accz = 0;
		          var result = 0;
		          var accRes=[];
		            var d_x = pos[this.thread.x][0] - pos[this.thread.y][0];
		            var d_y = pos[this.thread.x][1] - pos[this.thread.y][1];
		            var d_z = pos[this.thread.x][2] - pos[this.thread.y][2];
		            var radius = Math.pow(d_x, 2) + Math.pow(d_y, 2) + Math.pow(d_z, 2);
		            var rad2 = Math.sqrt(radius);
		            var grav_mag = 0.0;
		            if (this.thread.x!=0 && this.thread.x != this.thread.x && rad2 > 0.333 * (rad[this.thread.y] + rad[this.thread.x])) {
		              grav_mag = G / (Math.pow((radius ), (3.0 / 2.0)));
		              var grav_x = grav_mag * d_x;
		              var grav_y = grav_mag * d_y;
		              var grav_z = grav_mag * d_z;
		              accRes[0]= (0-(acc[this.thread.x][0] + grav_x * mass[this.thread.y]));
		              accRes[1]=(0-(acc[this.thread.x][1] + grav_y * mass[this.thread.y]));
		              accRes[2]=( 0-(acc[this.thread.x][2] + grav_z * mass[this.thread.y]));
		            } else {
		              //collision detected
		            }
		        return accRes;
		      }],function CombineAccs(){
		          var AllAccelerations =[[]];
		          var CombinedAccelerations = [];
		          AllAccelerations = AccelerateSingle(pos,mass, acc,rad,CurrentDimension);
		          for(var i=0;i<this.constants.size;i++){
		            CombinedAccelerations[this.thread.x]=CombinedAccelerations[this.thread.x]+AllAccelerations[i];
		          }
		          return CombinedAccelerations[this.thread.x];
		        })
		        .setConstants({size:this.gridSystem.pos.length})
		        //loopMaxIterations:this.gridSystem.pos.length}
		      .setOutput([this.gridSystem.pos.length,this.gridSystem.pos.length]);
		}

		function initGPUArray(){
		   var gpu = new GPU()
		        GPUcomputeAcceleration =  gpu.createKernel(function ( pos,mass, acc,rad,CurrentDimension){
		          var G = 2.93558 * Math.pow(10, -4);
		          var accx = 0;
		          var accy = 0;
		          var accz = 0;
		          var result = 0;
		          var accRes=[];
		          for(var i =0; i<this.constants.size; i++){
		            var d_x = pos[this.thread.x][0] - pos[i][0];
		            var d_y = pos[this.thread.x][1] - pos[i][1];
		            var d_z = pos[this.thread.x][2] - pos[i][2];
		            var radius = Math.pow(d_x, 2) + Math.pow(d_y, 2) + Math.pow(d_z, 2);
		            var rad2 = Math.sqrt(radius);
		            var grav_mag = 0.0;
		            if (this.thread.x!=0 && this.thread.x != i && rad2 > 0.333 * (rad[i] + rad[this.thread.x])) {
		              grav_mag = G / (Math.pow((radius ), (3.0 / 2.0)));
		              var grav_x = grav_mag * d_x;
		              var grav_y = grav_mag * d_y;
		              var grav_z = grav_mag * d_z;
		              accRes[0]=accRes[0] +(0-(acc[this.thread.x][0] + grav_x * mass[i]));
		              accRes[1]=accRes[1] + (0-(acc[this.thread.x][1] + grav_y * mass[i]));
		              accRes[2]=accRes[2] +( 0-(acc[this.thread.x][2] + grav_z * mass[i]));
		            } else {
		              //collision detected
		            }
		          }
		        return accRes;
		      },{dimensions:[this.gridSystem.pos.length],
		         constants: {size:this.gridSystem.pos.length},
		        loopMaxIterations:this.gridSystem.pos.length});
		}

		function initGPU(){
		        var gpu = new GPU()
		        GPUcomputeAcceleration =  gpu.createKernel(function (pos, mass, acc, rad){
		          var G = 2.93558 * Math.pow(10, -4);
		          var acc = 0;
		          var result = 0;
		          for(var i =0; i<this.constants.size; i++){
		            var d_x = pos[this.thread.x][0] - pos[i][0];
		            var d_y = pos[this.thread.x][1] - pos[i][1];
		            var d_z = pos[this.thread.x][2] - pos[i][2];
		            var radius = Math.pow(d_x, 2) + Math.pow(d_y, 2) + Math.pow(d_z, 2);
		            var rad2 = Math.sqrt(radius);
		            var grav_mag = 0.0;
		            if (this.thread.x!=0 && this.thread.x != i && rad2 > 0.333 * (rad[i] + rad[this.thread.x])) {
		              grav_mag = G / (Math.pow((radius ), (3.0 / 2.0)));
		              var grav = grav_mag * d_x;
		              acc += (0-(acc[this.thread.x][this.thread.y] + grav_x * mass[i]));
		            } else {
		              //collision detected
		            }
		          }
		      },{
		          output:[this.gridSystem.pos.length, 3],
		          constants: {size:this.gridSystem.pos.length},
		          loopMaxIterations:this.gridSystem.pos.length});
		}

		  function GPUAccelerate(){
		  var result = GPUcomputeAcceleration(
		                      gridSystem.pos,
		                      gridSystem.mass,
		                      gridSystem.acc,
		                      gridSystem.rad);
		  let bottom = []
		  for(let i =0;i<gridSystem.pos.length; i++)
		  {bottom.push(
		    [result[0][i],
		    result[1][i],
		    result[2][i]])}
		    console.log(bottom);
		  gridSystem.acc = bottom;
		}



		var gridSystem=getGridSystem();



		initGPU()

		for(var i=0;i<100;i++){
		  GPUAccelerate();
		}
    </script>
  </head>

	<body>
		<div id="info">

		</div>

    <div id="root"></div>


</html>
